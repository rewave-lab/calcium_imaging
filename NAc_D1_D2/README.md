This repository contains the codes developed for the methods used in the section "Calcium Data Analysis" of the manuscript "Dynamic Representation of Appetitive and Aversive Stimuli in Nucleus Accumbens Shell D1- and D2-Medium Spiny Neurons". It also includes example files for usage demonstration purposes.

# 1 - System Requirements
The "caiman_environment.yaml" file lists all the packages used in the conda environment and their respective versions for data analysis.

Among the Python packages used and tested on the Ubuntu 20.04 operating system, we highlight the following versions:

+ Python: 3.10.5
+ CaImAn: 1.9.12
+ Numpy: 1.23.1
+ Matplotlib: 3.8.4
+ Seaborn: 0.13.2
+ Pandas: 1.4.3
+ Scikit-learn: 1.1.1

# 2 - Installation Guide
For reproducing and using the provided codes, we recommend using Anaconda (Python distribution, https://www.anaconda.com/download) and following these steps for installation (these steps may take between 15 to 30 minutes).

```python
conda install -n base --override-channels -c conda-forge mamba 'python_abi=*=*cp*'
mamba create -n caiman -c conda-forge -c anaconda "caiman=1.9.12"
```

After that, you can activate the environment using this command:

```python
conda activate caiman
```
To complete the installation, please use these codes:

```python
pip install matplotlib==3.8.4 
pip install openpyxl==3.0.9
pip install seaborn==0.13.2
```

Note 1: Although the codes do not require extremely powerful computers, we suggest using a computer with at least 8 GB of RAM.

Note 2: This environment contains the Python package CaImAn version we used for all data preprocessing steps (see "preprocessing" folder for more information). For more details on using this package and appropriate documentation, please visit https://github.com/flatironinstitute/CaImAn

# 3 - Demo and Instructions for Use
For a demonstration of the developed codes, the "demo" folder contains mainly two files:

+ "MC.tiff_DF_filtered_all.txt": a file containing traces (DF/F) of identified neurons from an animal after preprocessing (CNMFe) and manual selection.

+ "Animal16-2023-04-23-101551.txt": a file containing time points of the task executed by the animal. For this example case, it represents day 10 of Pavlovian conditioning (CS + US).
Other files in this folder are generated by the codes provided here.

The methods used in our manuscript can be demonstrated using the above-described files and by using the Python format files (.py) present in this GitHub repository. To execute them, first ensure that the "caiman" environment is open and use the following command:

```python
python method.py
```
where 'method' should be replaced with the desired method. We list the methods present here:

+ Alignment of activity to behavioral events and Z-score (z_score.py, average execution time: 1 minute): This script processes 1-photon calcium imaging data and associated behavioral data to analyze neural activity in response to specific events (cues and consumption). The workflow is as follows: data preparation, extract event times (specific behavioral events: cues, rewards, pokes), identify consumption events, crop and process traces for cue (CS - conditioned stimuli) and consumption (US - unconditioned stimuli) and save processed data. Expected output: z-score files for CS and US events, as well as DF/F signal files for CS and US events.

+ Heatmaps (heatmaps.py, average execution time: 1 minute): This script is designed to generate heatmaps visualizing neural activity (represented as z-scores) in response to CS and US across a set of neurons. The process involves aligning the average neural responses to CS in descending order. Expected Output: Heatmap graph depicting the average neural responses aligned to CS in descending order.

+ Permutation test (permutation_test.py, average execution time: 1 minute): This script conducts an analysis of neuron activity in response to CS and US, categorizing their responses as excited, inhibited, or nonresponsive. Expected Output: Pie charts illustrating the distribution of cell responses to CS and US, along with files containing the classification of neurons based on their response types.

+ Z-score for trial-by-trial analyses (z_score-trial_analysis.py, average execution time: 1 minute): This code operates similarly to zscore.py, performing z-score calculations for each trial as described in the manuscript. Expected Output: The z-scores obtained for each trial were saved separately for CS and US stimuli.

+ Z-score for trial-by-trial analyses using shuffle data (z_score-trial_analysis_shuffle_data.py, average execution time: 1 minute): This code bears resemblance to z_score-trial_analysis.py, incorporating the shuffling of collected activity from each trial before computing the z-score, which will be utilized in the SVM model. Expected Output: The z-scores for shuffled data obtained for each trial, saved separately for CS and US stimuli

+ SVM to single cell decoding accuracy (svm-single_cell.py, average execution time: 5 minutes): This code is designed to employ an SVM model for classifying neuron responses to CS and US events. The evaluation assesses the performance of the SVM on both actual and shuffled data. Expected Output: Boxplots displaying the results for single-cell decoding accuracy for both actual and shuffled data.

+ SVM to population decoding accuracy (svm-population.py, average execution time: 1 minute): This code is intended to utilize an SVM model for population decoding, where responses from all neurons are combined (population vector) to differentiate between CS and US events. Expected Output: The calculation and printing of mean accuracies for comparison between actual and shuffled data

+ Neural trajectory (neural_trajectory.py, average execution time: 1 minute): This code calculates neural trajectories to illustrate population trial responses to CS and US events. It employs PCA to reduce data dimensionality. Expected Output: 3D plot depicting population response trajectories, showing separate trajectories for CS and US events as well as individual trials. Additionally, it calculates and displays the Euclidean distance between mean CS and US trajectories across time.

+ PSTH and AUC (PSTH_AUC_CS.py, average execution time: 1 minute): This code is similar to zscore.py but extends the response analysis time to 7 seconds (demonstrated here for responses to CS). Additionally, it generates a PSTH from the average activity and calculates the area under the curve (AUC) for each neuron's response within a 3-second stimulus response window. Expected output: PSTH plot of neuronal responses classified as inhibited or excited, and Excel files containing AUC values for cells classified as inhibited and excited.

+ Shannon’s entropy and percentage of persisted responses (shannon_entropy.py, average execution time: 3 minutes): This script analyzes neuronal activity data in response to CS and US stimuli. It classifies neuronal responses for each trial using permutation tests and calculates Shannon’s entropy to quantify the variability of responses. It also calculates the percentage of persisted responses. Expected output: histograms of entropy values and the percentage of persisted responses for different activity classifications, as well as heatmaps of neuronal responses by trials.

+ Single neuron activity correlation (single_neuron_activity_correlation.py, average execution time: 1 minute): This script computes the correlation of single-neuron activity across multiple trials for a specified stimulus (in this demonstration, the code performs correlations to the unconditioned stimulus, US). Expected Output: A histogram visualizing the distribution of correlations of single-neuron activity.

+ Tuning curve correlation (tuning_curve.py, average execution time: 2 minutes): This code calculates and visualizes the tuning curve correlation between different trials for CS and US. Expected output: heatmap of the tuning curve correlation matrix by trial and the mean correlation per distance between trials.
  
+ Stimulus correlation between days (stimulus_correlation_between_days.py, average execution time: 1 minute): This code calculates the correlation coefficients between neuronal activities on different days (in this example, the response activity to CS on days 1, 5, and 10 of Pavlovian conditioning for an animal). Expected output: a histogram of the distribution of correlation coefficients between pairs of different days.
  
+ Correlation between CS-US stimuli at the population level (CS-US_correlation.py, average execution time: 1 minute): This code visualizes the relationship between CS and US responses. Expected output: Scatter plots with linear regression lines and histograms of the angles between nearest neighbor points.

+ Population vector correlation (PV_correlation.py, average execution time: 1 minute): This code calculates the population vector correlation for tracked neurons across three different days (in this example, the response activity to CS on days 1, 5, and 10 of Pavlovian conditioning for an animal). Expected output: mean correlations within the same session and across different sessions.

+ Cluster Analysis (clustering.py, average execution time: 3 minutes): This code performs dimensionality reduction using PCA and applies the k-means clustering algorithm to the transformed data. Expected output: Plots showing the cumulative variance explained by each PCA component (to determine the number of components for dimensionality reduction), cosine similarity and silhouette score for selecting the optimal number of clusters using k-means, t-SNE plots, and heatmaps representing the clustering results.

# License
This project is covered under the CC-BY-NC-ND-4.0.
